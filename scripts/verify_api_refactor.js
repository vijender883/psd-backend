const mongoose = require("mongoose");
const axios = require("axios");
const dotenv = require("dotenv");
const Simulation = require("../models/Simulation");
const Problem = require("../models/Problem");
const path = require("path");

dotenv.config({ path: path.join(__dirname, "../.env") });

const BASE_URL = "http://localhost:3001/api";

async function verify() {
  console.log("Starting API Refactor Verification...");

  // 1. Connect to MongoDB
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log("‚úÖ Connected to MongoDB");
  } catch (error) {
    console.error("‚ùå Failed to connect to MongoDB:", error.message);
    process.exit(1);
  }

  const testSimId = `test_sim_${Date.now()}`;
  const testProblemId = `test_prob_${Date.now()}`;

  try {
    // 2. Create Test Problem
    const problem = new Problem({
      problemId: testProblemId,
      title: "Verification Problem",
      description: "Test problem for API refactor",
      inputFormat: "JSON string",
      outputFormat: "JSON string",
      constraints: ["None"],
      functionName: "solve_me",
      testCases: [
        { input: "[1, 2]", expectedOutput: "3" },
        { input: "[3, 4]", expectedOutput: "7" },
      ],
    });
    await problem.save();
    console.log(`‚úÖ Created test Problem: ${testProblemId}`);

    // 3. Create Test Simulation using new problemIds
    const simulation = new Simulation({
      simulationId: testSimId,
      title: "Verification Simulation",
      description: "Automated test",
      problemIds: [testProblemId],
      testsId: {
        mcqTests: [],
        dsaTests: [testProblemId], // Backward compat
      },
    });
    await simulation.save();
    console.log(`‚úÖ Created test Simulation: ${testSimId}`);

    // 4. Verify API Routes
    try {
      // Check server health
      // Assuming server is running at localhost:3001
      // If not, we skip API tests but DB tests passed
      try {
        await axios.get("http://localhost:3001/health");
        console.log("‚úÖ Server is running. Proceeding with API tests.");
      } catch (e) {
        console.warn(
          "‚ö†Ô∏è Server not reachable at http://localhost:3001. Skipping API route tests. Please ensure server is running to fully verify."
        );
        throw new Error("Server unreachable");
      }

      // 4a. GET /simulation/:id/problems
      console.log("Testing GET /simulation/:id/problems...");
      const problemsRes = await axios.get(
        `${BASE_URL}/code/simulation/${testSimId}/problems`
      );
      if (
        problemsRes.data.length === 1 &&
        problemsRes.data[0].id === testProblemId
      ) {
        console.log("‚úÖ GET /simulation/:id/problems returned correct data");
      } else {
        console.error(
          "‚ùå GET /simulation/:id/problems failed",
          problemsRes.data
        );
      }

      // 4b. GET /simulation/:id/problems/:problemId
      console.log("Testing GET /simulation/:id/problems/:problemId...");
      const problemRes = await axios.get(
        `${BASE_URL}/code/simulation/${testSimId}/problems/${testProblemId}`
      );
      if (problemRes.data.problemId === testProblemId) {
        console.log(
          "‚úÖ GET /simulation/:id/problems/:problemId returned correct data"
        );
      } else {
        console.error(
          "‚ùå GET /simulation/:id/problems/:problemId failed",
          problemRes.data
        );
      }

      // 4c. POST /simulations/:id/:user/:username/run
      console.log("Testing POST /run...");
      const runRes = await axios.post(
        `${BASE_URL}/code/simulations/${testSimId}/testUser/testUser/run`,
        {
          code: `
import sys
import json

def solve_me(arr):
    return sum(arr)

def generate_solve_me_wrapper():
    input_data = sys.stdin.read()
    # Handle potentially multiple JSON objects or lines
    try:
        # Try parsing as a single JSON list of inputs if your wrapper expects that
        # OR generic wrapper currently reads generic input.
        # Let's assume generic wrapper expects inputs line by line or json array?
        # Re-reading generic python wrapper:
        # It reads sys.stdin.read(), tries json.loads.
        # If list, iterates.
        pass
    except:
        pass
        
# Actually, I am sending the SOLUTION code, the wrapper is generated by backend.
# Generic wrapper:
# reads stdin. 
# parses args.
# calls function.
# prints result.

# My code just needs the function:
def solve_me(nums):
    return sum(nums)
        `,
          problemId: testProblemId,
          language: "python",
        }
      );

      console.log("Run response:", runRes.data);
      if (runRes.data.success) {
        console.log("‚úÖ POST /run execution successful");
      } else {
        console.error("‚ùå POST /run execution failed:", runRes.data);
      }
    } catch (apiError) {
      if (apiError.message !== "Server unreachable") {
        console.error(
          "‚ùå API Verification Failed:",
          apiError.response ? apiError.response.data : apiError.message
        );
      }
    }
  } catch (err) {
    console.error("‚ùå Verification Error:", err);
  } finally {
    // Cleanup
    if (testSimId) await Simulation.deleteOne({ simulationId: testSimId });
    if (testProblemId) await Problem.deleteOne({ problemId: testProblemId });
    console.log("üßπ Cleanup complete");
    await mongoose.disconnect();
  }
}

verify();
